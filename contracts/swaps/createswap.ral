// Protocol Contract

Contract Createswap (
    owner: Address,                                      // Developer Address
    contract: ByteVec,                                   // Swap Protocol
    mut numswaps: U256,                                  // Numswaps
    paca: ByteVec,                                       // Protocol Token Fee
    ngu: ByteVec,                                        // Protocol Token Fee
    mut pacafee: U256,                                   // $PACA Fee
    mut alphfee: U256,                                   // $ALPH Fee
    mut ngufee: U256                                     // $NGU Fee
) {
    // Events
    event Swap(tokeno: ByteVec, amto: U256, tokenw: ByteVec, amtw: U256, contract: ByteVec, conaddy: Address)
    event Destroy(who: Address)

    // Error Codes
    enum ErrorCodes {
        InvalidCaller = 1
    }

    // Public Functions
    pub fn getTokenId() -> ByteVec {
        return paca
    }

    pub fn getPacaFee() -> U256 {
        return pacafee
    }

    pub fn getAlphFee() -> U256 {
        return alphfee
    }

    pub fn getPacaToken() -> ByteVec {
        return paca
    }

    pub fn getNguToken() -> ByteVec {
        return ngu
    }

    pub fn getNguFee() -> U256 {
        return ngufee
    }

    // Contract Functions

    @using(preapprovedAssets = true, assetsInContract = false, updateFields = true, checkExternalCaller = false)
    pub fn createswappaca(tokenOffered: ByteVec, tokenOfferedAmt: U256, tokenWanted: ByteVec, tokenWantedAmt: U256) -> () {
        
        let minter = callerAddress!()

        let (encodeImmutableFields, encodeMutableFields) = Swap.encodeFields!(tokenOffered, tokenOfferedAmt, tokenWanted, tokenWantedAmt, minter, alphfee, selfAddress!())

        let contractID = copyCreateSubContract!{minter -> ALPH: 1 alph, tokenOffered: tokenOfferedAmt}(
            toByteVec!(numswaps),
            contract,                                                                                  
            encodeImmutableFields,
            encodeMutableFields
        )

        numswaps = numswaps + 1

        transferToken!(minter, owner, getPacaToken(), getAlphFee()) // alph fee collection

        emit Swap(tokenOffered, tokenOfferedAmt, tokenWanted, tokenWantedAmt, contractID, contractIdToAddress!(contractID))
    }

    @using(preapprovedAssets = true, assetsInContract = false, updateFields = true, checkExternalCaller = false)
    pub fn createswapngu(tokenOffered: ByteVec, tokenOfferedAmt: U256, tokenWanted: ByteVec, tokenWantedAmt: U256) -> () {
        
        let minter = callerAddress!()

        let (encodeImmutableFields, encodeMutableFields) = Swap.encodeFields!(tokenOffered, tokenOfferedAmt, tokenWanted, tokenWantedAmt, minter, alphfee, owner)

        let contractID = copyCreateSubContract!{minter -> ALPH: 1 alph, tokenOffered: tokenOfferedAmt}(
            toByteVec!(numswaps),
            contract,                                                                                  
            encodeImmutableFields,
            encodeMutableFields
        )

        numswaps = numswaps + 1

        transferToken!(minter, owner, getNguToken(), getNguFee()) // alph fee collection

        emit Swap(tokenOffered, tokenOfferedAmt, tokenWanted, tokenWantedAmt, contractID, contractIdToAddress!(contractID))
    }

    @using(preapprovedAssets = true, assetsInContract = false, updateFields = true, checkExternalCaller = false)
    pub fn createswapalph(tokenOffered: ByteVec, tokenOfferedAmt: U256, tokenWanted: ByteVec, tokenWantedAmt: U256) -> () {
        
        let minter = callerAddress!()

        let (encodeImmutableFields, encodeMutableFields) = Swap.encodeFields!(tokenOffered, tokenOfferedAmt, tokenWanted, tokenWantedAmt, minter, alphfee, owner)

        let contractID = copyCreateSubContract!{minter -> ALPH: 1 alph, tokenOffered: tokenOfferedAmt}(
            toByteVec!(numswaps),
            contract,                                                                                  
            encodeImmutableFields,
            encodeMutableFields
        )

        numswaps = numswaps + 1

        transferToken!(minter, owner, ALPH, getAlphFee()) // alph fee collection

        emit Swap(tokenOffered, tokenOfferedAmt, tokenWanted, tokenWantedAmt, contractID, contractIdToAddress!(contractID))
    }

    @using(preapprovedAssets = false, assetsInContract = false, updateFields = true, checkExternalCaller = false)
    pub fn feepaca(amount: U256) -> () {

        pacafee = amount

        //emit PacaFeeChange(pacafee)
    }

    @using(preapprovedAssets = false, assetsInContract = false, updateFields = true, checkExternalCaller = false)
    pub fn feealph(amount: U256) -> () {
        
        alphfee = amount

        //emit AlphFeeChange(alphfee)
    }

    @using(preapprovedAssets = false, assetsInContract = false, updateFields = true, checkExternalCaller = false)
    pub fn feengu(amount: U256) -> () {
        
        ngufee = amount

        //emit AlphFeeChange(alphfee)
    }

    @using(assetsInContract = true, updateFields = false, checkExternalCaller = true)
    pub fn destroytokenswap() -> () {

        let caller = callerAddress!()

        checkCaller!(owner == caller, ErrorCodes.InvalidCaller)

        destroySelf!(owner)

        emit Destroy(owner)
    }

}